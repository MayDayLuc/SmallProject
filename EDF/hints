Things to be done:

	1. reschedule the tasks based on their deadline rather than their arrivals
	2. Add ddl info to task like in , pass them upon creation
	3. Not change the task creation
	4. Schedule: Pick up a ready task whose ddl is earliest( ddl value are infinite)
	5. implement two sets of periodic tasks whose arrival times are all 0
	6. Print their switch behaviours and deadline violations if some tasks pass the ddl
	7. add a var compTime to store the residual clock tricks of a task,replenished to c 
	8. add a var for task's deadline
	9. two schedules has same deadline, than use a FIFO / queue

Method need to change :
OS_CORE.c

ostime_tick() : decrement the compTime counter in os_tcb: only for current task


OS_Sched(): print complete from who and change to who


OSIntexit() : print preempt from who to who

OSStart()

	Struct os_tcb() defined in uCOS-II.h

	TCB : uscii-o.h 	

























hint:
1. create a task that execute c units of time in every p units of time by (c , p)
2. Where to observe(printf) the switches of the tasks?
3. Call OSTaskCreate to create a task


A straightforward emulation of (c,p) 
	while(1)â€¨ { 
		Start=OSTimeGet() ; 
		While(OStimeGet()-start < c) ;
		OSTimeDly (p-c) ; 
	}

Problem: time may be preempted by tasks with higher priorities


Hints from Liu Jing:
add info in TCBextptr rather than tcb directly

